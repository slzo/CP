%{
	#include "tree.h"
	#define YYSTYPE TreeNode *

	TreeNode* root = new TreeNode(0, NODE_PROG);
	extern int lineno;

	extern bool parserError;

	// max_scope_id 是堆栈下一层结点的最大编号
	unsigned char max_scope_id = SCOPT_ID_BASE;
	string presentScope = "1";
	unsigned int top = 0;

	// multimap <标识符名称， 作用域> 变量名列表
	extern multimap<string, string> idNameList;
	// map <<标识符名称， 作用域>, 结点指针> 变量列表
	extern map<pair<string, string>, TreeNode*> idList;

	// 用于检查continue和break是否在循环内部
	bool inCycle = false;

	int yylex();
	int yyerror( char const * );
	int scopeCmp(string preScope, string varScope);
	void scopePush();
	void scopePop();
%}

// 类型
%token T_INT  T_VOID

// 赋值运算符
%token ASSIGN

// 括号分号逗号中括号
%token SEMICOLON COMMA LPAREN RPAREN LBRACE RBRACE LBRACKET RBRACKET

// 关键字
%token CONST IF_ ELSE WHILE_  BREAK CONTINUE RETURN

// 比较运算符
%token EQ GRAEQ LESEQ NEQ  GRA LES

// 普通计算
%token PLUS MINUS MUL DIV MOD AND OR NOT

// 特殊单词
%token IDENTIFIER INTEGER BOOL

%left EQ
%nonassoc IFF
%nonassoc ELSE
%%

CompUnit : Decl { root->addChild($1); }
		 | FuncDef { root->addChild($1); }
		 | CompUnit Decl { root->addChild($2); }
		 | CompUnit FuncDef { root->addChild($2); } ;
Decl : ConstDecl { $$ = $1; }
	 | VarDecl { $$ = $1; } ;
ConstDecl : CONST BasicType ConstDefs SEMICOLON {
				$$ = new TreeNode(lineno, NODE_STMT);
				$$->stype = STMT_CONSTDECL; $$->type = TYPE_NONE;
				$$->addChild($2); $$->addChild($3); TreeNode* p = $3->child;
				while(p != nullptr) {
					p->child->type->copy($2->type);
					p->child->type->constvar = true;
					p = p->sibling;
				}
			};
BasicType : T_INT {$$ = new TreeNode(lineno, NODE_TYPE); $$->type = TYPE_INT;}
		  | T_VOID {$$ = new TreeNode(lineno, NODE_TYPE); $$->type = TYPE_VOID;} ;
ConstDefs : ConstDef {$$ = new TreeNode(lineno, NODE_VARLIST); $$->addChild($1);}
		  | ConstDefs COMMA ConstDef {$$ = $1; $$->addChild($3);} ;
ConstDef : DeclIdentifier ASSIGN IntConst {
			$$ = new TreeNode(lineno, NODE_OP);
			$$->optype = OP_DECLASSIGN;
			$$->addChild($1);
			$$->addChild($3);
		   }
		 | ArrayDeclIdentifier ASSIGN LBRACE ArrayInitVal RBRACE {
			$$ = new TreeNode(lineno, NODE_OP);
			$$->optype = OP_DECLASSIGN;
			$$->addChild($1);
			$$->addChild($4);
		  } ;
DeclIdentifier : IDENTIFIER {
					$$ = $1;
					$$->var_scope = presentScope;
					$$->type = new Type(NOTYPE);
					if (idList.count(make_pair($$->var_name, $$->var_scope)) != 0) {
							string t = "Redeclared identifier : " + $$->var_name;
						yyerror(t.c_str());
					}
					idNameList.insert(make_pair($$->var_name, $$->var_scope));
					idList[make_pair($$->var_name, $$->var_scope)] = $$;
					} ;

IntConst : INTEGER {$$ = new TreeNode(lineno, NODE_EXPR); $$->addChild($1);} ;

ArrayDeclIdentifier : DeclIdentifier LBRACKET INTEGER RBRACKET {
						$$ = $1;
						$$->type->type = VALUE_ARRAY;
						$$->type->elementType = $1->type->type;
						$$->type->dimSize[$$->type->dim] = $3->int_val;
						$$->type->dim++;
						}
					| ArrayDeclIdentifier LBRACKET INTEGER RBRACKET {
						$$ = $1;
						$$->type->dimSize[$$->type->dim] = $3->int_val;
						$$->type->dim++;
						} ;

ArrayInitVal : IntConst {$$ = new TreeNode(lineno, NODE_VARLIST); $$->addChild($1);}
			 | ArrayInitVal COMMA IntConst {$$ = $1; $$->addChild($3);}
;

ArrayIdentifier : Identifier LBRACKET Exp RBRACKET {
					$$ = new TreeNode(lineno, NODE_OP);
					$$->optype = OP_INDEX;
					$$->addChild($1);
					// 计算数组偏移量倍数
					int biasRate = 1;
					for (unsigned int i = $1->type->visitDim + 1; i < $1->type->dim; i++) {
						biasRate *= $1->type->dimSize[i];
					}
					TreeNode* biasNode;
					if (biasRate == 1) {
						// 偏移倍数为1时省略乘法结点
						biasNode = $3;
					}
					else {
						biasNode = new TreeNode(lineno, NODE_OP);
						biasNode->optype = OP_MUL;
						biasNode->addChild($3);
						TreeNode* biasRateExpr = new TreeNode(lineno, NODE_EXPR);
						TreeNode* biasRateConst = new TreeNode(lineno, NODE_CONST);
						biasRateConst->type = TYPE_INT;
						biasRateConst->int_val = biasRate;
						biasRateExpr->addChild(biasRateConst);
						biasNode->addChild(biasRateExpr);
					}
					$1->type->visitDim++;
					$$->addChild(biasNode);
				}
				| ArrayIdentifier LBRACKET Exp RBRACKET {
					$$ = $1;
					TreeNode* newBiasNode = new TreeNode(lineno, NODE_OP);
					newBiasNode->optype = OP_ADD;
					newBiasNode->addChild($$->child->sibling);
					$$->child->sibling = newBiasNode;

					// 计算数组偏移量倍数
					int biasRate = 1;
					for (unsigned int i = $$->child->type->visitDim + 1; i < $$->child->type->dim; i++) {
						biasRate *= $$->child->type->dimSize[i];
					}

					TreeNode* biasNode;
					if (biasRate == 1) {
						// 偏移倍数为1时省略乘法结点
						biasNode = $3;
					}
					else {
						biasNode->optype = OP_MUL;
						biasNode->addChild($3);
						TreeNode* biasRateExpr = new TreeNode(lineno, NODE_EXPR);
						TreeNode* biasRateConst = new TreeNode(lineno, NODE_CONST);
						biasRateConst->type = TYPE_INT;
						biasRateConst->int_val = biasRate;
						biasRateExpr->addChild(biasRateConst);
						biasNode->addChild(biasRateExpr);
					}
					$$->child->type->visitDim++;
					newBiasNode->addChild(biasNode);
				}
				;
// ------ 复合标识符，包含指针与数组，在变量声明外使用 -----
CompIdentifier : Identifier {$$ = $1;}
				| ArrayIdentifier {
					$$ = $1;
					$$->child->type->visitDim = 0;
				} ;

// 数组标识符


Identifier : IDENTIFIER {
				$$ = $1;
				int idNameCount = idNameList.count($$->var_name);
				int declCnt = 0;
				int minDefDis = MAX_SCOPE_STACK;

				// 搜索变量是否已经声明
				auto it = idNameList.find($$->var_name);
				int resScoptCmp;
				while (idNameCount--) {
					resScoptCmp = scopeCmp(presentScope, it->second);
					if (resScoptCmp >= 0){
						// 寻找最近的定义
						if (resScoptCmp < minDefDis) {
							minDefDis = resScoptCmp;
							$$ = idList[make_pair(it->first, it->second)];
						}
						declCnt++;
					}
					it++;
				}
				if (declCnt == 0) {
					string t = "Undeclared identifier :'" + $1->var_name + "', scope : " + to_string(resScoptCmp);
					yyerror(t.c_str());
				}
			};


DeclCompIdentifier : DeclIdentifier {$$ = $1;}
				   | ArrayDeclIdentifier {$$ = $1;} ;

VarDecl : BasicType VarDefs SEMICOLON {
			$$ = new TreeNode(lineno, NODE_STMT);
			$$->stype = STMT_DECL;
			$$->type = TYPE_NONE;
			$$->addChild($1);
			$$->addChild($2);
			TreeNode* p = $2->child;
			while(p != nullptr) {
				if (p->nodeType == NODE_OP) {
					p->child->type->copy($1->type);
				}
				else {
					p->type->copy($1->type);
				}
				p = p->sibling;
			}
		} ;

// 连续变量定义
VarDefs : VarDef {$$ = new TreeNode(lineno, NODE_VARLIST); $$->addChild($1);}
		| VarDefs COMMA VarDef {$$ = $1; $$->addChild($3);} ;

VarDef : DeclCompIdentifier {$$ = $1;}
	   | DeclCompIdentifier ASSIGN Exp {
			$$ = new TreeNode(lineno, NODE_OP);
			$$->optype = OP_DECLASSIGN;
			$$->addChild($1);
			$$->addChild($3);
		}
	   | ArrayDeclIdentifier ASSIGN LBRACE ArrayInitVal RBRACE {
			$$ = new TreeNode(lineno, NODE_OP);
			$$->optype = OP_DECLASSIGN;
			$$->addChild($1);
			$$->addChild($4);
		} ;

FuncDef : BasicType DeclIdentifier funcLPAREN FuncFParams RPAREN LBRACE BlockItems RBRACE {
				$$ = new TreeNode(lineno, NODE_STMT);
				$$->stype = STMT_FUNCDECL;
				$2->type->type = COMPOSE_FUNCTION;
				TreeNode* param = $4;
				while (param != nullptr) {
					$2->type->paramType[$2->type->paramNum] = param->child->type;
					$2->type->paramNum++;
					param = param->sibling;
				}
				$2->type->retType = $1->type;
				$$->addChild($1);
				$$->addChild($2);
				TreeNode* params = new TreeNode(lineno, NODE_VARLIST);
				params->addChild($4);
				$$->addChild(params);
				TreeNode* funcBlock = new TreeNode(lineno, NODE_STMT);
				funcBlock->stype = STMT_BLOCK;
				funcBlock->addChild($7);
				$$->addChild(funcBlock);
				scopePop();
			}
		| BasicType DeclIdentifier funcLPAREN RPAREN LBRACE BlockItems RBRACE {
			$$ = new TreeNode(lineno, NODE_STMT);
			$$->stype = STMT_FUNCDECL;
			$2->type->type = COMPOSE_FUNCTION;
			$2->type->retType = $1->type;
			$$->addChild($1);
			$$->addChild($2);
			$$->addChild(new TreeNode(lineno, NODE_VARLIST));
			TreeNode* funcBlock = new TreeNode(lineno, NODE_STMT);
			funcBlock->stype = STMT_BLOCK;
			funcBlock->addChild($6);
			$$->addChild(funcBlock);
			scopePop();
		} ;

funcLPAREN : LPAREN {scopePush();};

FuncFParams : FuncFParam {$$ = $1;}
			| FuncFParams COMMA FuncFParam {$$ = $1; $$->addSibling($3);} ;

FuncFParam : BasicType DeclIdentifier {
				$$ = new TreeNode(lineno, NODE_PARAM);
				$$->addChild($1);
				$$->addChild($2);
				$2->type->copy($1->type);
			} ;


Block : BlockLBRACE BlockItems BlockRBRACE {
			$$ = new TreeNode(lineno, NODE_STMT);
			$$->stype = STMT_BLOCK;
			$$->addChild($2);
		} ;

BlockLBRACE : LBRACE {scopePush();};
BlockRBRACE : RBRACE {scopePop();};

BlockItems : BlockItem {$$ = $1;}
		   | BlockItems BlockItem {$$ = $1; $$->addSibling($2);} ;

BlockItem : Decl {$$ = $1;}
		  | Stmt {$$ = $1;} ;


Stmt : SEMICOLON {$$ = new TreeNode(lineno, NODE_STMT); $$->stype = STMT_SKIP;}
	 | Exp SEMICOLON {$$ = $1;}
	 | Block {$$ = $1;}
	 | IF LPAREN Cond RPAREN Stmt %prec IFF{
		$$ = new TreeNode(lineno, NODE_STMT);
		$$->stype = STMT_IF;
		$$->addChild($3);
		$$->addChild($5);
		scopePop();
		}
	 | IF LPAREN Cond RPAREN Stmt ELSE Stmt {
		$$ = new TreeNode(lineno, NODE_STMT);
		$$->stype = STMT_IFELSE;
		$$->addChild($3);
		$$->addChild($5);
		$$->addChild($7);
		scopePop();
		}
	 | WHILE LPAREN Cond RPAREN Stmt {
			$$ = new TreeNode(lineno, NODE_STMT);
			$$->stype = STMT_WHILE;
			$$->addChild($3);
			$$->addChild($5);
			inCycle = false;
			scopePop();
		}

	 | BREAK SEMICOLON {
			if (!inCycle) {
				yyerror("break statement outside loop");
			}
			$$ = new TreeNode(lineno, NODE_STMT);
			$$->stype = STMT_BREAK;
			$$->type = TYPE_NONE;
		}
	 | CONTINUE SEMICOLON{
			if (!inCycle) {
				yyerror("continue statement outside loop");
			}
			$$ = new TreeNode(lineno, NODE_STMT);
			$$->stype = STMT_CONTINUE;
			$$->type = TYPE_NONE;
		}
	 | RETURN SEMICOLON {$$ = new TreeNode(lineno, NODE_STMT); $$->stype = STMT_RETURN; $$->type = TYPE_NONE;}
	 | RETURN Exp SEMICOLON {$$ = new TreeNode(lineno, NODE_STMT); $$->stype = STMT_RETURN; $$->addChild($2); $$->type = TYPE_NONE;}
;

IF : IF_ {scopePush();};
WHILE : WHILE_ {inCycle = true; scopePush();};


Exp : AddExp {$$ = $1;}
	| CompIdentifier ASSIGN Exp {
		$$ = new TreeNode(lineno, NODE_OP);
		$$->optype = OP_ASSIGN;
		$$->addChild($1);
		$$->addChild($3);
	  } ;

Cond : LOrExp {$$ = $1;};

UnaryExp : PrimaryExp {$$ = $1;}
		 | Identifier LPAREN FuncRParams RPAREN {
				$$ = new TreeNode(lineno, NODE_FUNCALL);
				$$->addChild($1);
				$$->addChild($3);
			}
		 | Identifier LPAREN RPAREN {
				$$ = new TreeNode(lineno, NODE_FUNCALL);
				$$->addChild($1);
				$$->addChild(new TreeNode(lineno, NODE_VARLIST));
			}
		 | PLUS UnaryExp {$$ = new TreeNode(lineno, NODE_OP); $$->optype = OP_POS; $$->addChild($2);}
		 | MINUS UnaryExp {$$ = new TreeNode(lineno, NODE_OP); $$->optype = OP_NAG; $$->addChild($2);}
		 | NOT UnaryExp {$$ = new TreeNode(lineno, NODE_OP); $$->optype = OP_NOT; $$->addChild($2);} ;

PrimaryExp : LPAREN Exp RPAREN {$$ = $2;}
			| LPAREN Cond RPAREN {$$ = $2;}
			| IntConst {$$ = $1;}
			| CompIdentifier {$$ = new TreeNode(lineno, NODE_EXPR); $$->addChild($1);} ;

FuncRParams : Exp {$$ = new TreeNode(lineno, NODE_VARLIST); $$->addChild($1);}
			| FuncRParams COMMA Exp {$$ = $1; $$->addChild($3);} ;


MulExp : UnaryExp {$$ = $1;}
		| MulExp MUL UnaryExp {$$ = new TreeNode(lineno, NODE_OP); $$->optype = OP_MUL; $$->addChild($1); $$->addChild($3);}
		| MulExp DIV UnaryExp {$$ = new TreeNode(lineno, NODE_OP); $$->optype = OP_DIV; $$->addChild($1); $$->addChild($3);}
		| MulExp MOD UnaryExp {$$ = new TreeNode(lineno, NODE_OP); $$->optype = OP_MOD; $$->addChild($1); $$->addChild($3);} ;

AddExp : MulExp {$$ = $1;}
		| AddExp PLUS MulExp {$$ = new TreeNode(lineno, NODE_OP); $$->optype = OP_ADD; $$->addChild($1); $$->addChild($3);}
		| AddExp MINUS MulExp {$$ = new TreeNode(lineno, NODE_OP); $$->optype = OP_SUB; $$->addChild($1); $$->addChild($3);} ;


RelExp : AddExp {$$ = $1;}
		| RelExp GRA AddExp {$$ = new TreeNode(lineno, NODE_OP); $$->optype = OP_GRA; $$->addChild($1); $$->addChild($3);}
		| RelExp LES AddExp {$$ = new TreeNode(lineno, NODE_OP); $$->optype = OP_LES; $$->addChild($1); $$->addChild($3);}
		| RelExp GRAEQ AddExp {$$ = new TreeNode(lineno, NODE_OP); $$->optype = OP_GRAEQ; $$->addChild($1); $$->addChild($3);}
		| RelExp LESEQ AddExp {$$ = new TreeNode(lineno, NODE_OP); $$->optype = OP_LESEQ; $$->addChild($1); $$->addChild($3);} ;

EqExp : RelExp {$$ = $1;}
	  | RelExp EQ EqExp {$$ = new TreeNode(lineno, NODE_OP); $$->optype = OP_EQ; $$->addChild($1); $$->addChild($3);}
	  | RelExp NEQ EqExp {$$ = new TreeNode(lineno, NODE_OP); $$->optype = OP_NEQ; $$->addChild($1); $$->addChild($3);} ;

LAndExp : EqExp {$$ = $1;}
		 | EqExp AND LAndExp {$$ = new TreeNode(lineno, NODE_OP); $$->optype = OP_AND; $$->addChild($1); $$->addChild($3);} ;

LOrExp : LAndExp {$$ = $1;}
		| LAndExp OR LOrExp {$$ = new TreeNode(lineno, NODE_OP); $$->optype = OP_OR; $$->addChild($1); $$->addChild($3);} ;

%%

int yyerror(char const * message)
{
	cout << "error: " << message << ", at line " << lineno << endl;
	parserError = true;
	return 0;
}

int scopeCmp(string presScope, string varScope) {
	unsigned int plen = presScope.length(), vlen = varScope.length();
	unsigned int minlen = min(plen, vlen);
	if (presScope.substr(0, minlen) == varScope.substr(0, minlen)) {
		if (plen >= vlen)
			return plen - vlen;
		else
			return -1;
	}
	return -2;
}

void scopePush() {
	presentScope += max_scope_id;
	max_scope_id = SCOPT_ID_BASE;
	top++;
}

void scopePop() {
	max_scope_id = presentScope[top] + 1;
	presentScope = presentScope.substr(0, presentScope.length() - 1);
	top--;
}
